//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined): Observable<AuthenticationResponseResponse> {
        let url_ = this.baseUrl + "/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponseResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<AuthenticationResponseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined): Observable<AuthenticationResponseResponse> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponseResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticationResponseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EventPlaceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @param language (optional) 
     * @param seatingChart (optional) 
     * @param seatingChartImage (optional) 
     * @param columns (optional) 
     * @param rows (optional) 
     * @return Success
     */
    createOne(name: string | undefined, language: Language | undefined, seatingChart: SeatingChart | undefined, seatingChartImage: FileParameter | undefined, columns: number | undefined, rows: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/event-place/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (language === null || language === undefined)
            throw new Error("The parameter 'language' cannot be null.");
        else
            content_.append("Language", language.toString());
        if (seatingChart === null || seatingChart === undefined)
            throw new Error("The parameter 'seatingChart' cannot be null.");
        else
            content_.append("SeatingChart", seatingChart.toString());
        if (seatingChartImage === null || seatingChartImage === undefined)
            throw new Error("The parameter 'seatingChartImage' cannot be null.");
        else
            content_.append("SeatingChartImage", seatingChartImage.data, seatingChartImage.fileName ? seatingChartImage.fileName : "SeatingChartImage");
        if (columns === null || columns === undefined)
            throw new Error("The parameter 'columns' cannot be null.");
        else
            content_.append("Columns", columns.toString());
        if (rows === null || rows === undefined)
            throw new Error("The parameter 'rows' cannot be null.");
        else
            content_.append("Rows", rows.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllData(): Observable<EventPlaceDtoListResponse> {
        let url_ = this.baseUrl + "/event-place/get-all-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventPlaceDtoListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventPlaceDtoListResponse>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<EventPlaceDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventPlaceDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    getAll(page: number | undefined, size: number | undefined): Observable<EventPlaceDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/event-place/get-all?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventPlaceDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventPlaceDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EventPlaceDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventPlaceDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<GetEventPlaceDtoResponse> {
        let url_ = this.baseUrl + "/event-place/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEventPlaceDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEventPlaceDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<GetEventPlaceDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEventPlaceDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param name (optional) 
     * @param seatingChart (optional) 
     * @param seatingChartImagePath (optional) 
     * @param columns (optional) 
     * @param rows (optional) 
     * @return Success
     */
    editOne(id: number | undefined, name: string | undefined, seatingChart: SeatingChart | undefined, seatingChartImagePath: FileParameter | undefined, columns: number | undefined, rows: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/event-place/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (seatingChart === null || seatingChart === undefined)
            throw new Error("The parameter 'seatingChart' cannot be null.");
        else
            content_.append("SeatingChart", seatingChart.toString());
        if (seatingChartImagePath === null || seatingChartImagePath === undefined)
            throw new Error("The parameter 'seatingChartImagePath' cannot be null.");
        else
            content_.append("SeatingChartImagePath", seatingChartImagePath.data, seatingChartImagePath.fileName ? seatingChartImagePath.fileName : "SeatingChartImagePath");
        if (columns === null || columns === undefined)
            throw new Error("The parameter 'columns' cannot be null.");
        else
            content_.append("Columns", columns.toString());
        if (rows === null || rows === undefined)
            throw new Error("The parameter 'rows' cannot be null.");
        else
            content_.append("Rows", rows.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/event-place/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EventsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOne(body: CreateEventDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/events/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    getAll(page: number | undefined, size: number | undefined): Observable<GetEventsDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/events/get-all?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEventsDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEventsDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetEventsDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEventsDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllData(): Observable<GetEventsDtoListResponse> {
        let url_ = this.baseUrl + "/events/get-all-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEventsDtoListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEventsDtoListResponse>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<GetEventsDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEventsDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<GetEventDtoResponse> {
        let url_ = this.baseUrl + "/events/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEventDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEventDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<GetEventDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEventDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param nameArabic (optional) 
     * @param nameEnglish (optional) 
     * @param description (optional) 
     * @param eventDate (optional) 
     * @param eventPlaceId (optional) 
     * @return Success
     */
    editOne(id: number | undefined, nameArabic: string | undefined, nameEnglish: string | undefined, description: string | undefined, eventDate: Date | undefined, eventPlaceId: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/events/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (nameArabic === null || nameArabic === undefined)
            throw new Error("The parameter 'nameArabic' cannot be null.");
        else
            content_.append("NameArabic", nameArabic.toString());
        if (nameEnglish === null || nameEnglish === undefined)
            throw new Error("The parameter 'nameEnglish' cannot be null.");
        else
            content_.append("NameEnglish", nameEnglish.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (eventDate === null || eventDate === undefined)
            throw new Error("The parameter 'eventDate' cannot be null.");
        else
            content_.append("EventDate", eventDate.toJSON());
        if (eventPlaceId === null || eventPlaceId === undefined)
            throw new Error("The parameter 'eventPlaceId' cannot be null.");
        else
            content_.append("EventPlaceId", eventPlaceId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/events/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FirstTitleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOne(body: CreateFirstTitleDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/first-title/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    getAll(page: number | undefined, size: number | undefined): Observable<GetTitleFirstDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/first-title/get-all?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTitleFirstDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTitleFirstDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetTitleFirstDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTitleFirstDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllData(): Observable<GetTitleFirstDtoListResponse> {
        let url_ = this.baseUrl + "/first-title/get-all-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTitleFirstDtoListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTitleFirstDtoListResponse>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<GetTitleFirstDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTitleFirstDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<TitleFirstDtoResponse> {
        let url_ = this.baseUrl + "/first-title/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleFirstDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleFirstDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<TitleFirstDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TitleFirstDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editOne(body: UpdateTitleDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/first-title/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/first-title/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InvitationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOne(body: InvitationCreateDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/invitation/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    getAll(page: number | undefined, size: number | undefined): Observable<GetInvitationsDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/invitation/get-all?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInvitationsDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInvitationsDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetInvitationsDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvitationsDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<InvitationDtoResponse> {
        let url_ = this.baseUrl + "/invitation/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvitationDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvitationDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<InvitationDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvitationDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editOne(body: UpdateInvitationDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/invitation/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/invitation/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PersonTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOne(body: CreatePersonTypeDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/person-type/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    getAll(page: number | undefined, size: number | undefined): Observable<GetPersonTypeDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/person-type/get-all?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPersonTypeDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPersonTypeDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetPersonTypeDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPersonTypeDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllData(): Observable<GetPersonTypeDtoListResponse> {
        let url_ = this.baseUrl + "/person-type/get-all-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPersonTypeDtoListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPersonTypeDtoListResponse>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<GetPersonTypeDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPersonTypeDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<PersonTypeDtoResponse> {
        let url_ = this.baseUrl + "/person-type/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonTypeDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonTypeDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<PersonTypeDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonTypeDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editOne(body: UpdatePersonTypeDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/person-type/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/person-type/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SeatsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSeats(body: CreateSeatsDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/seats/create-seats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSeats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSeats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateSeats(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param eventId (optional) 
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    getAll(eventId: number | undefined, page: number | undefined, size: number | undefined): Observable<GetSeatsDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/seats/get-all?";
        if (eventId === null)
            throw new Error("The parameter 'eventId' cannot be null.");
        else if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSeatsDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSeatsDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetSeatsDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSeatsDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/seats/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editOne(body: UpdateASeatDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/seats/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bookSeat(body: BookASeatDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/seats/book-seat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBookSeat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookSeat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processBookSeat(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    nonTakenSeats(body: AllSeatsRequestDto | undefined): Observable<AllSeatsDtoListResponse> {
        let url_ = this.baseUrl + "/seats/non-taken-seats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNonTakenSeats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNonTakenSeats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllSeatsDtoListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllSeatsDtoListResponse>;
        }));
    }

    protected processNonTakenSeats(response: HttpResponseBase): Observable<AllSeatsDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AllSeatsDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SeatsTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @param color (optional) 
     * @param colorText (optional) 
     * @param seatImage (optional) 
     * @return Success
     */
    createOne(name: string | undefined, color: string | undefined, colorText: string | undefined, seatImage: FileParameter | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/seats-types/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (color === null || color === undefined)
            throw new Error("The parameter 'color' cannot be null.");
        else
            content_.append("Color", color.toString());
        if (colorText === null || colorText === undefined)
            throw new Error("The parameter 'colorText' cannot be null.");
        else
            content_.append("ColorText", colorText.toString());
        if (seatImage === null || seatImage === undefined)
            throw new Error("The parameter 'seatImage' cannot be null.");
        else
            content_.append("SeatImage", seatImage.data, seatImage.fileName ? seatImage.fileName : "SeatImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllData(): Observable<AllSeatsTypeDtoListResponse> {
        let url_ = this.baseUrl + "/seats-types/get-all-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllSeatsTypeDtoListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllSeatsTypeDtoListResponse>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<AllSeatsTypeDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AllSeatsTypeDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    getAll(page: number | undefined, size: number | undefined): Observable<GetSeatsTypeDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/seats-types/get-all?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSeatsTypeDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSeatsTypeDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetSeatsTypeDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSeatsTypeDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<SeatsTypeDtoResponse> {
        let url_ = this.baseUrl + "/seats-types/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeatsTypeDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeatsTypeDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<SeatsTypeDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeatsTypeDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param name (optional) 
     * @param color (optional) 
     * @param colorText (optional) 
     * @param seatImage (optional) 
     * @return Success
     */
    editOne(id: number | undefined, name: string | undefined, color: string | undefined, colorText: string | undefined, seatImage: FileParameter | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/seats-types/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (color === null || color === undefined)
            throw new Error("The parameter 'color' cannot be null.");
        else
            content_.append("Color", color.toString());
        if (colorText === null || colorText === undefined)
            throw new Error("The parameter 'colorText' cannot be null.");
        else
            content_.append("ColorText", colorText.toString());
        if (seatImage === null || seatImage === undefined)
            throw new Error("The parameter 'seatImage' cannot be null.");
        else
            content_.append("SeatImage", seatImage.data, seatImage.fileName ? seatImage.fileName : "SeatImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/seats-types/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SecondTitleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOne(body: CreateSecondTitleDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/second-title/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    getAll(page: number | undefined, size: number | undefined): Observable<GetTitleSecondDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/second-title/get-all?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTitleSecondDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTitleSecondDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetTitleSecondDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTitleSecondDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllData(): Observable<GetTitleSecondDtoListResponse> {
        let url_ = this.baseUrl + "/second-title/get-all-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTitleSecondDtoListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTitleSecondDtoListResponse>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<GetTitleSecondDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTitleSecondDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<TitleSecondDtoResponse> {
        let url_ = this.baseUrl + "/second-title/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleSecondDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleSecondDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<TitleSecondDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TitleSecondDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editOne(body: UpdateTitleSecondDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/second-title/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/second-title/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AllSeatsDto implements IAllSeatsDto {
    id?: number;
    code?: string | undefined;
    seatType?: string | undefined;

    constructor(data?: IAllSeatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.seatType = _data["seatType"];
        }
    }

    static fromJS(data: any): AllSeatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllSeatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["seatType"] = this.seatType;
        return data;
    }
}

export interface IAllSeatsDto {
    id?: number;
    code?: string | undefined;
    seatType?: string | undefined;
}

export class AllSeatsDtoListResponse implements IAllSeatsDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: AllSeatsDto[] | undefined;
    byteData?: string | undefined;

    constructor(data?: IAllSeatsDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AllSeatsDto.fromJS(item));
            }
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): AllSeatsDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AllSeatsDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IAllSeatsDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: AllSeatsDto[] | undefined;
    byteData?: string | undefined;
}

export class AllSeatsRequestDto implements IAllSeatsRequestDto {
    eventId?: number;

    constructor(data?: IAllSeatsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
        }
    }

    static fromJS(data: any): AllSeatsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllSeatsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        return data;
    }
}

export interface IAllSeatsRequestDto {
    eventId?: number;
}

export class AllSeatsTypeDto implements IAllSeatsTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;

    constructor(data?: IAllSeatsTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.color = _data["color"];
            this.colorText = _data["colorText"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): AllSeatsTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllSeatsTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["color"] = this.color;
        data["colorText"] = this.colorText;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface IAllSeatsTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;
}

export class AllSeatsTypeDtoListResponse implements IAllSeatsTypeDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: AllSeatsTypeDto[] | undefined;
    byteData?: string | undefined;

    constructor(data?: IAllSeatsTypeDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AllSeatsTypeDto.fromJS(item));
            }
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): AllSeatsTypeDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AllSeatsTypeDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IAllSeatsTypeDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: AllSeatsTypeDto[] | undefined;
    byteData?: string | undefined;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    id?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["email"] = this.email;
        data["token"] = this.token;
        return data;
    }
}

export interface IAuthenticationResponse {
    id?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;
}

export class AuthenticationResponseResponse implements IAuthenticationResponseResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: AuthenticationResponse;
    byteData?: string | undefined;

    constructor(data?: IAuthenticationResponseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? AuthenticationResponse.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): AuthenticationResponseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IAuthenticationResponseResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: AuthenticationResponse;
    byteData?: string | undefined;
}

export class BookASeatDto implements IBookASeatDto {
    invitationId?: number;
    seatPlaceId?: number;

    constructor(data?: IBookASeatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invitationId = _data["invitationId"];
            this.seatPlaceId = _data["seatPlaceId"];
        }
    }

    static fromJS(data: any): BookASeatDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookASeatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invitationId"] = this.invitationId;
        data["seatPlaceId"] = this.seatPlaceId;
        return data;
    }
}

export interface IBookASeatDto {
    invitationId?: number;
    seatPlaceId?: number;
}

export class BooleanResponse implements IBooleanResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: boolean;
    byteData?: string | undefined;

    constructor(data?: IBooleanResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"];
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): BooleanResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IBooleanResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: boolean;
    byteData?: string | undefined;
}

export class CreateEventDto implements ICreateEventDto {
    nameArabic?: string | undefined;
    nameEnglish?: string | undefined;
    description?: string | undefined;
    eventPlaceId?: number;
    eventDate?: Date;

    constructor(data?: ICreateEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameArabic = _data["nameArabic"];
            this.nameEnglish = _data["nameEnglish"];
            this.description = _data["description"];
            this.eventPlaceId = _data["eventPlaceId"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameArabic"] = this.nameArabic;
        data["nameEnglish"] = this.nameEnglish;
        data["description"] = this.description;
        data["eventPlaceId"] = this.eventPlaceId;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateEventDto {
    nameArabic?: string | undefined;
    nameEnglish?: string | undefined;
    description?: string | undefined;
    eventPlaceId?: number;
    eventDate?: Date;
}

export class CreateFirstTitleDto implements ICreateFirstTitleDto {
    name?: string | undefined;

    constructor(data?: ICreateFirstTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateFirstTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFirstTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateFirstTitleDto {
    name?: string | undefined;
}

export class CreatePersonTypeDto implements ICreatePersonTypeDto {
    name?: string | undefined;
    color?: string | undefined;

    constructor(data?: ICreatePersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): CreatePersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["color"] = this.color;
        return data;
    }
}

export interface ICreatePersonTypeDto {
    name?: string | undefined;
    color?: string | undefined;
}

export class CreateSeatsDto implements ICreateSeatsDto {
    eventPlaceId?: number;
    seatTypeId?: number;
    prefix?: Prefixes;
    start?: number;
    count?: number;

    constructor(data?: ICreateSeatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventPlaceId = _data["eventPlaceId"];
            this.seatTypeId = _data["seatTypeId"];
            this.prefix = _data["prefix"];
            this.start = _data["start"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CreateSeatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSeatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventPlaceId"] = this.eventPlaceId;
        data["seatTypeId"] = this.seatTypeId;
        data["prefix"] = this.prefix;
        data["start"] = this.start;
        data["count"] = this.count;
        return data;
    }
}

export interface ICreateSeatsDto {
    eventPlaceId?: number;
    seatTypeId?: number;
    prefix?: Prefixes;
    start?: number;
    count?: number;
}

export class CreateSecondTitleDto implements ICreateSecondTitleDto {
    name?: string | undefined;

    constructor(data?: ICreateSecondTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSecondTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSecondTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateSecondTitleDto {
    name?: string | undefined;
}

export class EventPlaceDto implements IEventPlaceDto {
    id?: number;
    name?: string | undefined;
    seatingChart?: SeatingChart;
    seatingChartImagePath?: string | undefined;
    columns?: number | undefined;
    rows?: number | undefined;

    constructor(data?: IEventPlaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.seatingChart = _data["seatingChart"];
            this.seatingChartImagePath = _data["seatingChartImagePath"];
            this.columns = _data["columns"];
            this.rows = _data["rows"];
        }
    }

    static fromJS(data: any): EventPlaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventPlaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["seatingChart"] = this.seatingChart;
        data["seatingChartImagePath"] = this.seatingChartImagePath;
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        return data;
    }
}

export interface IEventPlaceDto {
    id?: number;
    name?: string | undefined;
    seatingChart?: SeatingChart;
    seatingChartImagePath?: string | undefined;
    columns?: number | undefined;
    rows?: number | undefined;
}

export class EventPlaceDtoListResponse implements IEventPlaceDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: EventPlaceDto[] | undefined;
    byteData?: string | undefined;

    constructor(data?: IEventPlaceDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EventPlaceDto.fromJS(item));
            }
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): EventPlaceDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EventPlaceDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IEventPlaceDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: EventPlaceDto[] | undefined;
    byteData?: string | undefined;
}

export class EventPlaceDtoPagedResult implements IEventPlaceDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: EventPlaceDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IEventPlaceDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EventPlaceDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): EventPlaceDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new EventPlaceDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IEventPlaceDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: EventPlaceDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class EventPlaceDtoPagedResultResponse implements IEventPlaceDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: EventPlaceDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IEventPlaceDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? EventPlaceDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): EventPlaceDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EventPlaceDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IEventPlaceDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: EventPlaceDtoPagedResult;
    byteData?: string | undefined;
}

export enum FormType {
    Internal = 1,
    External = 2,
}

export class GetEventDto implements IGetEventDto {
    id?: number;
    nameArabic?: string | undefined;
    nameEnglish?: string | undefined;
    description?: string | undefined;
    eventDate?: Date;
    eventPlaceId?: number;

    constructor(data?: IGetEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameArabic = _data["nameArabic"];
            this.nameEnglish = _data["nameEnglish"];
            this.description = _data["description"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.eventPlaceId = _data["eventPlaceId"];
        }
    }

    static fromJS(data: any): GetEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameArabic"] = this.nameArabic;
        data["nameEnglish"] = this.nameEnglish;
        data["description"] = this.description;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["eventPlaceId"] = this.eventPlaceId;
        return data;
    }
}

export interface IGetEventDto {
    id?: number;
    nameArabic?: string | undefined;
    nameEnglish?: string | undefined;
    description?: string | undefined;
    eventDate?: Date;
    eventPlaceId?: number;
}

export class GetEventDtoResponse implements IGetEventDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventDto;
    byteData?: string | undefined;

    constructor(data?: IGetEventDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetEventDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetEventDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetEventDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventDto;
    byteData?: string | undefined;
}

export class GetEventPlaceDto implements IGetEventPlaceDto {
    id?: number;
    name?: string | undefined;
    seatingChart?: SeatingChart;
    seatingChartImagePath?: string | undefined;
    columns?: number | undefined;
    rows?: number | undefined;

    constructor(data?: IGetEventPlaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.seatingChart = _data["seatingChart"];
            this.seatingChartImagePath = _data["seatingChartImagePath"];
            this.columns = _data["columns"];
            this.rows = _data["rows"];
        }
    }

    static fromJS(data: any): GetEventPlaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventPlaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["seatingChart"] = this.seatingChart;
        data["seatingChartImagePath"] = this.seatingChartImagePath;
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        return data;
    }
}

export interface IGetEventPlaceDto {
    id?: number;
    name?: string | undefined;
    seatingChart?: SeatingChart;
    seatingChartImagePath?: string | undefined;
    columns?: number | undefined;
    rows?: number | undefined;
}

export class GetEventPlaceDtoResponse implements IGetEventPlaceDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventPlaceDto;
    byteData?: string | undefined;

    constructor(data?: IGetEventPlaceDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetEventPlaceDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetEventPlaceDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventPlaceDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetEventPlaceDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventPlaceDto;
    byteData?: string | undefined;
}

export class GetEventsDto implements IGetEventsDto {
    id?: number;
    nameArabic?: string | undefined;
    nameEnglish?: string | undefined;
    description?: string | undefined;
    eventDate?: Date;
    eventPlaceName?: string | undefined;

    constructor(data?: IGetEventsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameArabic = _data["nameArabic"];
            this.nameEnglish = _data["nameEnglish"];
            this.description = _data["description"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.eventPlaceName = _data["eventPlaceName"];
        }
    }

    static fromJS(data: any): GetEventsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameArabic"] = this.nameArabic;
        data["nameEnglish"] = this.nameEnglish;
        data["description"] = this.description;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["eventPlaceName"] = this.eventPlaceName;
        return data;
    }
}

export interface IGetEventsDto {
    id?: number;
    nameArabic?: string | undefined;
    nameEnglish?: string | undefined;
    description?: string | undefined;
    eventDate?: Date;
    eventPlaceName?: string | undefined;
}

export class GetEventsDtoListResponse implements IGetEventsDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDto[] | undefined;
    byteData?: string | undefined;

    constructor(data?: IGetEventsDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetEventsDto.fromJS(item));
            }
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetEventsDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventsDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetEventsDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDto[] | undefined;
    byteData?: string | undefined;
}

export class GetEventsDtoPagedResult implements IGetEventsDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetEventsDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetEventsDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetEventsDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventsDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetEventsDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetEventsDtoPagedResultResponse implements IGetEventsDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetEventsDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetEventsDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetEventsDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventsDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetEventsDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDtoPagedResult;
    byteData?: string | undefined;
}

export class GetInvitationsDto implements IGetInvitationsDto {
    id?: number;
    createdAt?: Date;
    eventId?: number;
    titleFirstId?: number;
    titleSecondId?: number | undefined;
    personTypeId?: number;
    fullName?: string | undefined;
    seatCode?: string | undefined;
    email?: string | undefined;
    whatsapp?: string | undefined;
    phone?: string | undefined;
    position?: string | undefined;
    party?: string | undefined;
    sendWhatsapp?: boolean;
    sendEmail?: boolean;
    language?: Language;
    invitationStatus?: InvitationStatus;
    formType?: FormType;
    confirmAttendance?: boolean;

    constructor(data?: IGetInvitationsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.eventId = _data["eventId"];
            this.titleFirstId = _data["titleFirstId"];
            this.titleSecondId = _data["titleSecondId"];
            this.personTypeId = _data["personTypeId"];
            this.fullName = _data["fullName"];
            this.seatCode = _data["seatCode"];
            this.email = _data["email"];
            this.whatsapp = _data["whatsapp"];
            this.phone = _data["phone"];
            this.position = _data["position"];
            this.party = _data["party"];
            this.sendWhatsapp = _data["sendWhatsapp"];
            this.sendEmail = _data["sendEmail"];
            this.language = _data["language"];
            this.invitationStatus = _data["invitationStatus"];
            this.formType = _data["formType"];
            this.confirmAttendance = _data["confirmAttendance"];
        }
    }

    static fromJS(data: any): GetInvitationsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvitationsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["eventId"] = this.eventId;
        data["titleFirstId"] = this.titleFirstId;
        data["titleSecondId"] = this.titleSecondId;
        data["personTypeId"] = this.personTypeId;
        data["fullName"] = this.fullName;
        data["seatCode"] = this.seatCode;
        data["email"] = this.email;
        data["whatsapp"] = this.whatsapp;
        data["phone"] = this.phone;
        data["position"] = this.position;
        data["party"] = this.party;
        data["sendWhatsapp"] = this.sendWhatsapp;
        data["sendEmail"] = this.sendEmail;
        data["language"] = this.language;
        data["invitationStatus"] = this.invitationStatus;
        data["formType"] = this.formType;
        data["confirmAttendance"] = this.confirmAttendance;
        return data;
    }
}

export interface IGetInvitationsDto {
    id?: number;
    createdAt?: Date;
    eventId?: number;
    titleFirstId?: number;
    titleSecondId?: number | undefined;
    personTypeId?: number;
    fullName?: string | undefined;
    seatCode?: string | undefined;
    email?: string | undefined;
    whatsapp?: string | undefined;
    phone?: string | undefined;
    position?: string | undefined;
    party?: string | undefined;
    sendWhatsapp?: boolean;
    sendEmail?: boolean;
    language?: Language;
    invitationStatus?: InvitationStatus;
    formType?: FormType;
    confirmAttendance?: boolean;
}

export class GetInvitationsDtoPagedResult implements IGetInvitationsDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetInvitationsDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetInvitationsDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetInvitationsDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetInvitationsDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvitationsDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetInvitationsDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetInvitationsDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetInvitationsDtoPagedResultResponse implements IGetInvitationsDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetInvitationsDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetInvitationsDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetInvitationsDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetInvitationsDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvitationsDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetInvitationsDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetInvitationsDtoPagedResult;
    byteData?: string | undefined;
}

export class GetPersonTypeDto implements IGetPersonTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;

    constructor(data?: IGetPersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): GetPersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["color"] = this.color;
        return data;
    }
}

export interface IGetPersonTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;
}

export class GetPersonTypeDtoListResponse implements IGetPersonTypeDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDto[] | undefined;
    byteData?: string | undefined;

    constructor(data?: IGetPersonTypeDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetPersonTypeDto.fromJS(item));
            }
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetPersonTypeDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonTypeDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetPersonTypeDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDto[] | undefined;
    byteData?: string | undefined;
}

export class GetPersonTypeDtoPagedResult implements IGetPersonTypeDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetPersonTypeDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetPersonTypeDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetPersonTypeDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonTypeDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetPersonTypeDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetPersonTypeDtoPagedResultResponse implements IGetPersonTypeDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetPersonTypeDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetPersonTypeDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetPersonTypeDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonTypeDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetPersonTypeDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDtoPagedResult;
    byteData?: string | undefined;
}

export class GetSeatsDto implements IGetSeatsDto {
    id?: number;
    code?: string | undefined;
    eventPlaceName?: string | undefined;
    seatTypeName?: string | undefined;
    isTaken?: boolean;

    constructor(data?: IGetSeatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.eventPlaceName = _data["eventPlaceName"];
            this.seatTypeName = _data["seatTypeName"];
            this.isTaken = _data["isTaken"];
        }
    }

    static fromJS(data: any): GetSeatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["eventPlaceName"] = this.eventPlaceName;
        data["seatTypeName"] = this.seatTypeName;
        data["isTaken"] = this.isTaken;
        return data;
    }
}

export interface IGetSeatsDto {
    id?: number;
    code?: string | undefined;
    eventPlaceName?: string | undefined;
    seatTypeName?: string | undefined;
    isTaken?: boolean;
}

export class GetSeatsDtoPagedResult implements IGetSeatsDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetSeatsDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetSeatsDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetSeatsDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetSeatsDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeatsDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetSeatsDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetSeatsDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetSeatsDtoPagedResultResponse implements IGetSeatsDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetSeatsDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetSeatsDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetSeatsDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetSeatsDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeatsDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetSeatsDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetSeatsDtoPagedResult;
    byteData?: string | undefined;
}

export class GetSeatsTypeDto implements IGetSeatsTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;

    constructor(data?: IGetSeatsTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.color = _data["color"];
            this.colorText = _data["colorText"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): GetSeatsTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeatsTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["color"] = this.color;
        data["colorText"] = this.colorText;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface IGetSeatsTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;
}

export class GetSeatsTypeDtoPagedResult implements IGetSeatsTypeDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetSeatsTypeDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetSeatsTypeDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetSeatsTypeDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetSeatsTypeDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeatsTypeDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetSeatsTypeDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetSeatsTypeDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetSeatsTypeDtoPagedResultResponse implements IGetSeatsTypeDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetSeatsTypeDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetSeatsTypeDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetSeatsTypeDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetSeatsTypeDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeatsTypeDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetSeatsTypeDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetSeatsTypeDtoPagedResult;
    byteData?: string | undefined;
}

export class GetTitleFirstDto implements IGetTitleFirstDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IGetTitleFirstDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetTitleFirstDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleFirstDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGetTitleFirstDto {
    id?: number;
    name?: string | undefined;
}

export class GetTitleFirstDtoListResponse implements IGetTitleFirstDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDto[] | undefined;
    byteData?: string | undefined;

    constructor(data?: IGetTitleFirstDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetTitleFirstDto.fromJS(item));
            }
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetTitleFirstDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleFirstDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetTitleFirstDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDto[] | undefined;
    byteData?: string | undefined;
}

export class GetTitleFirstDtoPagedResult implements IGetTitleFirstDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetTitleFirstDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetTitleFirstDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetTitleFirstDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleFirstDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetTitleFirstDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetTitleFirstDtoPagedResultResponse implements IGetTitleFirstDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetTitleFirstDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetTitleFirstDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetTitleFirstDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleFirstDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetTitleFirstDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDtoPagedResult;
    byteData?: string | undefined;
}

export class GetTitleSecondDto implements IGetTitleSecondDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;

    constructor(data?: IGetTitleSecondDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
            this.color = _data["color"];
            this.colorText = _data["colorText"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): GetTitleSecondDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleSecondDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        data["color"] = this.color;
        data["colorText"] = this.colorText;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface IGetTitleSecondDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;
}

export class GetTitleSecondDtoListResponse implements IGetTitleSecondDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDto[] | undefined;
    byteData?: string | undefined;

    constructor(data?: IGetTitleSecondDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetTitleSecondDto.fromJS(item));
            }
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetTitleSecondDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleSecondDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetTitleSecondDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDto[] | undefined;
    byteData?: string | undefined;
}

export class GetTitleSecondDtoPagedResult implements IGetTitleSecondDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetTitleSecondDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetTitleSecondDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetTitleSecondDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleSecondDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetTitleSecondDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetTitleSecondDtoPagedResultResponse implements IGetTitleSecondDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetTitleSecondDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetTitleSecondDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetTitleSecondDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleSecondDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetTitleSecondDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDtoPagedResult;
    byteData?: string | undefined;
}

export class InvitationCreateDto implements IInvitationCreateDto {
    eventId?: number;
    titleFirstId?: number;
    titleSecondId?: number;
    personTypeId?: number;
    fullName?: string | undefined;
    email?: string | undefined;
    whatsapp?: string | undefined;
    phone?: string | undefined;
    position?: string | undefined;
    party?: string | undefined;
    sendWhatsapp?: boolean;
    hasCameToEvent?: boolean;
    sendEmail?: boolean;
    language?: Language;
    invitationStatus?: InvitationStatus;
    formType?: FormType;

    constructor(data?: IInvitationCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.titleFirstId = _data["titleFirstId"];
            this.titleSecondId = _data["titleSecondId"];
            this.personTypeId = _data["personTypeId"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.whatsapp = _data["whatsapp"];
            this.phone = _data["phone"];
            this.position = _data["position"];
            this.party = _data["party"];
            this.sendWhatsapp = _data["sendWhatsapp"];
            this.hasCameToEvent = _data["hasCameToEvent"];
            this.sendEmail = _data["sendEmail"];
            this.language = _data["language"];
            this.invitationStatus = _data["invitationStatus"];
            this.formType = _data["formType"];
        }
    }

    static fromJS(data: any): InvitationCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvitationCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["titleFirstId"] = this.titleFirstId;
        data["titleSecondId"] = this.titleSecondId;
        data["personTypeId"] = this.personTypeId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["whatsapp"] = this.whatsapp;
        data["phone"] = this.phone;
        data["position"] = this.position;
        data["party"] = this.party;
        data["sendWhatsapp"] = this.sendWhatsapp;
        data["hasCameToEvent"] = this.hasCameToEvent;
        data["sendEmail"] = this.sendEmail;
        data["language"] = this.language;
        data["invitationStatus"] = this.invitationStatus;
        data["formType"] = this.formType;
        return data;
    }
}

export interface IInvitationCreateDto {
    eventId?: number;
    titleFirstId?: number;
    titleSecondId?: number;
    personTypeId?: number;
    fullName?: string | undefined;
    email?: string | undefined;
    whatsapp?: string | undefined;
    phone?: string | undefined;
    position?: string | undefined;
    party?: string | undefined;
    sendWhatsapp?: boolean;
    hasCameToEvent?: boolean;
    sendEmail?: boolean;
    language?: Language;
    invitationStatus?: InvitationStatus;
    formType?: FormType;
}

export class InvitationDto implements IInvitationDto {
    id?: number;
    createdAt?: Date;
    eventId?: number;
    titleFirstId?: number;
    titleSecondId?: number | undefined;
    personTypeId?: number;
    fullName?: string | undefined;
    email?: string | undefined;
    whatsapp?: string | undefined;
    phone?: string | undefined;
    position?: string | undefined;
    party?: string | undefined;
    sendWhatsapp?: boolean;
    sendEmail?: boolean;
    confirmAttendance?: boolean;
    language?: Language;
    invitationStatus?: InvitationStatus;
    formType?: FormType;

    constructor(data?: IInvitationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.eventId = _data["eventId"];
            this.titleFirstId = _data["titleFirstId"];
            this.titleSecondId = _data["titleSecondId"];
            this.personTypeId = _data["personTypeId"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.whatsapp = _data["whatsapp"];
            this.phone = _data["phone"];
            this.position = _data["position"];
            this.party = _data["party"];
            this.sendWhatsapp = _data["sendWhatsapp"];
            this.sendEmail = _data["sendEmail"];
            this.confirmAttendance = _data["confirmAttendance"];
            this.language = _data["language"];
            this.invitationStatus = _data["invitationStatus"];
            this.formType = _data["formType"];
        }
    }

    static fromJS(data: any): InvitationDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvitationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["eventId"] = this.eventId;
        data["titleFirstId"] = this.titleFirstId;
        data["titleSecondId"] = this.titleSecondId;
        data["personTypeId"] = this.personTypeId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["whatsapp"] = this.whatsapp;
        data["phone"] = this.phone;
        data["position"] = this.position;
        data["party"] = this.party;
        data["sendWhatsapp"] = this.sendWhatsapp;
        data["sendEmail"] = this.sendEmail;
        data["confirmAttendance"] = this.confirmAttendance;
        data["language"] = this.language;
        data["invitationStatus"] = this.invitationStatus;
        data["formType"] = this.formType;
        return data;
    }
}

export interface IInvitationDto {
    id?: number;
    createdAt?: Date;
    eventId?: number;
    titleFirstId?: number;
    titleSecondId?: number | undefined;
    personTypeId?: number;
    fullName?: string | undefined;
    email?: string | undefined;
    whatsapp?: string | undefined;
    phone?: string | undefined;
    position?: string | undefined;
    party?: string | undefined;
    sendWhatsapp?: boolean;
    sendEmail?: boolean;
    confirmAttendance?: boolean;
    language?: Language;
    invitationStatus?: InvitationStatus;
    formType?: FormType;
}

export class InvitationDtoResponse implements IInvitationDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: InvitationDto;
    byteData?: string | undefined;

    constructor(data?: IInvitationDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? InvitationDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): InvitationDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InvitationDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IInvitationDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: InvitationDto;
    byteData?: string | undefined;
}

export enum InvitationStatus {
    UnderConsideration = 1,
    Sent = 2,
    Confirmed = 3,
    Apologized = 4,
}

export enum Language {
    Arabic = 1,
    English = 2,
}

export class LoginRequest implements ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class PersonTypeDto implements IPersonTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;

    constructor(data?: IPersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): PersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["color"] = this.color;
        return data;
    }
}

export interface IPersonTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;
}

export class PersonTypeDtoResponse implements IPersonTypeDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: PersonTypeDto;
    byteData?: string | undefined;

    constructor(data?: IPersonTypeDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? PersonTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): PersonTypeDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PersonTypeDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IPersonTypeDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: PersonTypeDto;
    byteData?: string | undefined;
}

export enum Prefixes {
    A = 1,
    B = 2,
    C = 3,
    D = 4,
    E = 5,
    F = 6,
    G = 7,
    H = 8,
    I = 9,
    J = 10,
    K = 11,
    L = 12,
    M = 13,
    N = 14,
    O = 15,
    P = 16,
    Q = 17,
    R = 18,
    S = 19,
    T = 20,
    U = 21,
    V = 22,
    W = 23,
    X = 24,
    Y = 25,
    Z = 26,
}

export class RegisterRequest implements IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
}

export enum SeatingChart {
    ColsRows = 1,
    Circular = 2,
}

export class SeatsTypeDto implements ISeatsTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;

    constructor(data?: ISeatsTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.color = _data["color"];
            this.colorText = _data["colorText"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): SeatsTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeatsTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["color"] = this.color;
        data["colorText"] = this.colorText;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface ISeatsTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;
}

export class SeatsTypeDtoResponse implements ISeatsTypeDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: SeatsTypeDto;
    byteData?: string | undefined;

    constructor(data?: ISeatsTypeDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? SeatsTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): SeatsTypeDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SeatsTypeDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface ISeatsTypeDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: SeatsTypeDto;
    byteData?: string | undefined;
}

export class TitleFirstDto implements ITitleFirstDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: ITitleFirstDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TitleFirstDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleFirstDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ITitleFirstDto {
    id?: number;
    name?: string | undefined;
}

export class TitleFirstDtoResponse implements ITitleFirstDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: TitleFirstDto;
    byteData?: string | undefined;

    constructor(data?: ITitleFirstDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? TitleFirstDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): TitleFirstDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TitleFirstDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface ITitleFirstDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: TitleFirstDto;
    byteData?: string | undefined;
}

export class TitleSecondDto implements ITitleSecondDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: ITitleSecondDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TitleSecondDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleSecondDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ITitleSecondDto {
    id?: number;
    name?: string | undefined;
}

export class TitleSecondDtoResponse implements ITitleSecondDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: TitleSecondDto;
    byteData?: string | undefined;

    constructor(data?: ITitleSecondDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? TitleSecondDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): TitleSecondDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TitleSecondDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface ITitleSecondDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: TitleSecondDto;
    byteData?: string | undefined;
}

export class UpdateASeatDto implements IUpdateASeatDto {
    id?: number;
    code?: string | undefined;
    eventPlaceId?: number;
    seatTypeId?: number;

    constructor(data?: IUpdateASeatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.eventPlaceId = _data["eventPlaceId"];
            this.seatTypeId = _data["seatTypeId"];
        }
    }

    static fromJS(data: any): UpdateASeatDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateASeatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["eventPlaceId"] = this.eventPlaceId;
        data["seatTypeId"] = this.seatTypeId;
        return data;
    }
}

export interface IUpdateASeatDto {
    id?: number;
    code?: string | undefined;
    eventPlaceId?: number;
    seatTypeId?: number;
}

export class UpdateInvitationDto implements IUpdateInvitationDto {
    id?: number;
    eventId?: number;
    titleFirstId?: number;
    titleSecondId?: number;
    personTypeId?: number;
    fullName?: string | undefined;
    email?: string | undefined;
    whatsapp?: string | undefined;
    phone?: string | undefined;
    position?: string | undefined;
    party?: string | undefined;
    sendWhatsapp?: boolean;
    hasCameToEvent?: boolean;
    sendEmail?: boolean;
    language?: Language;
    invitationStatus?: InvitationStatus;
    formType?: FormType;

    constructor(data?: IUpdateInvitationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.eventId = _data["eventId"];
            this.titleFirstId = _data["titleFirstId"];
            this.titleSecondId = _data["titleSecondId"];
            this.personTypeId = _data["personTypeId"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.whatsapp = _data["whatsapp"];
            this.phone = _data["phone"];
            this.position = _data["position"];
            this.party = _data["party"];
            this.sendWhatsapp = _data["sendWhatsapp"];
            this.hasCameToEvent = _data["hasCameToEvent"];
            this.sendEmail = _data["sendEmail"];
            this.language = _data["language"];
            this.invitationStatus = _data["invitationStatus"];
            this.formType = _data["formType"];
        }
    }

    static fromJS(data: any): UpdateInvitationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvitationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["eventId"] = this.eventId;
        data["titleFirstId"] = this.titleFirstId;
        data["titleSecondId"] = this.titleSecondId;
        data["personTypeId"] = this.personTypeId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["whatsapp"] = this.whatsapp;
        data["phone"] = this.phone;
        data["position"] = this.position;
        data["party"] = this.party;
        data["sendWhatsapp"] = this.sendWhatsapp;
        data["hasCameToEvent"] = this.hasCameToEvent;
        data["sendEmail"] = this.sendEmail;
        data["language"] = this.language;
        data["invitationStatus"] = this.invitationStatus;
        data["formType"] = this.formType;
        return data;
    }
}

export interface IUpdateInvitationDto {
    id?: number;
    eventId?: number;
    titleFirstId?: number;
    titleSecondId?: number;
    personTypeId?: number;
    fullName?: string | undefined;
    email?: string | undefined;
    whatsapp?: string | undefined;
    phone?: string | undefined;
    position?: string | undefined;
    party?: string | undefined;
    sendWhatsapp?: boolean;
    hasCameToEvent?: boolean;
    sendEmail?: boolean;
    language?: Language;
    invitationStatus?: InvitationStatus;
    formType?: FormType;
}

export class UpdatePersonTypeDto implements IUpdatePersonTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;

    constructor(data?: IUpdatePersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): UpdatePersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["color"] = this.color;
        return data;
    }
}

export interface IUpdatePersonTypeDto {
    id?: number;
    name?: string | undefined;
    color?: string | undefined;
}

export class UpdateTitleDto implements IUpdateTitleDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IUpdateTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateTitleDto {
    id?: number;
    name?: string | undefined;
}

export class UpdateTitleSecondDto implements IUpdateTitleSecondDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IUpdateTitleSecondDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateTitleSecondDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTitleSecondDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateTitleSecondDto {
    id?: number;
    name?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}